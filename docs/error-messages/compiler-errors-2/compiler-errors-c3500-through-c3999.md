---
description: "Learn more about: Compiler errors C3500 through C3999"
title: "Compiler errors C3500 through C3999"
ms.date: "04/21/2019"
f1_keywords: ["C3502", "C3503", "C3504", "C3511", "C3512", "C3513", "C3514", "C3515", "C3516", "C3517", "C3518", "C3520", "C3521", "C3522", "C3523", "C3524", "C3525", "C3526", "C3527", "C3528", "C3529", "C3534", "C3542", "C3543", "C3544", "C3545", "C3546", "C3547", "C3548", "C3549", "C3557", "C3558", "C3559", "C3560", "C3561", "C3562", "C3563", "C3564", "C3565", "C3566", "C3567", "C3568", "C3569", "C3570", "C3571", "C3572", "C3573", "C3574", "C3575", "C3576", "C3577", "C3578", "C3579", "C3580", "C3581", "C3582", "C3583", "C3584", "C3585", "C3586", "C3587", "C3588", "C3589", "C3590", "C3591", "C3592", "C3593", "C3594", "C3595", "C3596", "C3597", "C3598", "C3599", "C3600", "C3601", "C3602", "C3604", "C3605", "C3613", "C3614", "C3616", "C3620", "C3621", "C3635", "C3636", "C3649", "C3658", "C3659", "C3660", "C3663", "C3664", "C3667", "C3674", "C3676", "C3677", "C3678", "C3679", "C3680", "C3681", "C3682", "C3683", "C3684", "C3685", "C3686", "C3687", "C3688", "C3689", "C3690", "C3691", "C3696", "C3716", "C3720", "C3725", "C3726", "C3729", "C3730", "C3735", "C3742", "C3746", "C3750", "C3751", "C3756", "C3757", "C3758", "C3759", "C3760", "C3770", "C3773", "C3774", "C3775", "C3776", "C3777", "C3778", "C3779", "C3780", "C3781", "C3782", "C3783", "C3784", "C3785", "C3786", "C3787", "C3801", "C3802", "C3806", "C3811", "C3814", "C3819", "C3822", "C3823", "C3826", "C3827", "C3829", "C3837", "C3840", "C3841", "C3843", "C3844", "C3845", "C3863", "C3870", "C3871", "C3875", "C3879", "C3881", "C3882", "C3884", "C3885", "C3897", "C3905", "C3906", "C3916", "C3921", "C3924", "C3925", "C3926", "C3927", "C3928", "C3930", "C3931", "C3932", "C3933", "C3934", "C3935", "C3936", "C3937", "C3938", "C3939", "C3940", "C3941", "C3945", "C3946", "C3947", "C3948", "C3949", "C3950", "C3951", "C3952", "C3953", "C3954", "C3955", "C3956", "C3957", "C3958", "C3959", "C3960", "C3961", "C3962", "C3963", "C3964", "C3965", "C3966", "C3967", "C3968", "C3969", "C3970", "C3971", "C3972", "C3975", "C3976", "C3977", "C3978", "C3979", "C3980", "C3981", "C3982", "C3983", "C3984", "C3985", "C3986", "C3987", "C3988", "C3989", "C3990", "C3991", "C3992", "C3993", "C3994", "C3995", "C3996", "C3997", "C3998", "C3999"]
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
---
# Compiler errors C3500 through C3999

The articles in this section of the documentation explain a subset of the error messages that are generated by the compiler.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## Error messages

|Error|Message|
|-----------|-------------|
|[Compiler error C3500](compiler-error-c3500.md)|invalid ProgID '*progid*'|
|[Compiler error C3501](compiler-error-c3501.md)|there is no typelib registered for ProgID '*progid*'|
|Compiler error C3502|cannot obtain LIBID for ProgID '*progid*'|
|Compiler error C3503|character '0x*value*' is not allowed in a raw string literal|
|Compiler error C3504|cannot create GUID from string '*string*'|
|[Compiler error C3505](compiler-error-c3505.md)|cannot load type library '*library*'|
|[Compiler error C3506](compiler-error-c3506.md)|there is no typelib registered for LIBID '*library*'|
|[Compiler error C3507](compiler-error-c3507.md)|a ProgID can have no more than 39 characters '*progid*'; nor contain any punctuation apart from '.'; nor start with a digit|
|[Compiler error C3508](compiler-error-c3508.md)|'*type*': is not a valid Automation type|
|[Compiler error C3509](compiler-error-c3509.md)|'*type*': invalid Automation return type; when a parameter is marked 'retval', the return type must be 'void', 'HRESULT' or 'SCODE'|
|[Compiler error C3510](compiler-error-c3510.md)|cannot locate dependent type library *library*|
|Compiler error C3511|'*identifier*': a call to a delegating constructor shall be the only member-initializer|
|Compiler error C3512|the delimiting character sequence for a raw string literal shall have no more than 16 characters|
|Compiler error C3513|'*string*': unsupported raw string literal delimiter character|
|Compiler error C3514|'*character*' (*value*): unsupported raw string literal delimiter character|
|Compiler error C3515|if an argument for a class template partial specialization is a pack expansion it shall be the last argument|
|Compiler error C3516|unexpected end-of-file found while processing the raw string literal; delimiter sequence '*string*' was not matched|
|Compiler error C3517|'*identifier*' an alias-declaration cannot have a type that contains 'auto'|
|Compiler error C3518|'*identifier*': in a direct-list-initialization context the type for '*type*' can only be deduced from a single initializer expression|
|[Compiler error C3519](compiler-error-c3519.md)|'*parameter*': invalid parameter to embedded_idl attribute|
|Compiler error C3520|'*identifier*': parameter pack must be expanded in this context|
|Compiler error C3521|'*identifier*' is not a parameter pack|
|Compiler error C3522|'*type*': parameter pack cannot be expanded in this context|
|Compiler error C3523|'sizeof...' requires as its argument an unexpanded parameter pack|
|Compiler error C3524|'*identifier*': 'sizeof' cannot be applied to a parameter pack. Did you mean to use 'sizeof...'?|
|Compiler error C3525|'*parameter*': if a class template has a template parameter pack it must appear at the end of the template parameter list|
|Compiler error C3526|'...' cannot be applied to 'this'|
|Compiler error C3527|'*identifier*' is not a valid operand for 'sizeof...'. Did you mean to use 'sizeof'?|
|Compiler error C3528|'*identifier1*': the number of elements in this pack expansion does not match the number of elements in '*identifier2*'|
|Compiler error C3529|'*parameter*': a template parameter pack cannot have a default argument|
|[Compiler error C3530](compiler-error-c3530.md)|'*type*' cannot be combined with any other type-specifier|
|[Compiler error C3531](compiler-error-c3531.md)|'*identifier*': a symbol whose type contains '*type*' must have an initializer|
|[Compiler error C3532](compiler-error-c3532.md)|the element type of an array cannot be a type that contains '*type*'|
|[Compiler error C3533](compiler-error-c3533.md)|a parameter cannot have a type that contains '*type*'|
|Compiler error C3534|Obsolete.|
|[Compiler error C3535](compiler-error-c3535.md)|cannot deduce type for '*type1*' from '*type2*'|
|[Compiler error C3536](compiler-error-c3536.md)|'*identifier*': cannot be used before it is initialized|
|[Compiler error C3537](compiler-error-c3537.md)|you cannot cast to a type that contains '*type*'|
|[Compiler error C3538](compiler-error-c3538.md)|in a declarator-list '*type*' must always deduce to the same type|
|[Compiler error C3539](compiler-error-c3539.md)|a template-argument cannot be a type that contains '*type*'|
|[Compiler error C3540](compiler-error-c3540.md)|sizeof cannot be applied to a type that contains '*type*'|
|[Compiler error C3541](compiler-error-c3541.md)|typeid cannot be applied to a type that contains '*type*'|
|Compiler error C3542|'*identifier*': a virtual member function shall not have a return type that contains '*type*'|
|Compiler error C3543|'*type*': does not contain a parameter pack|
|Compiler error C3544|'*parameter*': parameter pack expects a type template argument|
|Compiler error C3545|'*parameter*': parameter pack expects a non-type template argument|
|Compiler error C3546|'...': there are no parameter packs available to expand|
|Compiler error C3547|template parameter '*parameter*' cannot be used because it follows a template parameter pack and cannot be deduced from the function parameters of '*function*'|
|Compiler error C3548|'*identifier*': parameter pack cannot be used in this context|
|Compiler error C3549|'*value*': a function parameter pack cannot have a default argument|
|[Compiler error C3550](compiler-error-c3550.md)|only plain 'decltype(auto)' is allowed in this context|
|[Compiler error C3551](compiler-error-c3551.md)|if a trailing return type is used then the leading return type shall be the single type-specifier 'auto' (not '*type*')|
|[Compiler error C3552](compiler-error-c3552.md)|expected 'decltype(auto)'|
|[Compiler error C3553](compiler-error-c3553.md)|decltype expects an expression not a type|
|[Compiler error C3554](compiler-error-c3554.md)|'*type*' cannot be combined with any other type-specifier|
|[Compiler error C3555](compiler-error-c3555.md)|incorrect argument to 'decltype'|
|[Compiler error C3556](compiler-error-c3556.md)|'*expression*': incorrect argument to 'decltype'|
|Compiler error C3557|Obsolete.|
|Compiler error C3558|Obsolete.|
|Compiler error C3559|recursive call to '*function*': recursion is detected when compiling the call graph for the concurrency::parallel_for_each at: '*function*'|
|Compiler error C3560|'*function*': IL is not available when compiling the call graph for the concurrency::parallel_for_each at: '*function*'|
|Compiler error C3561|tile barrier operation found in control flow that is not tile-uniform when compiling the call graph for the concurrency::parallel_for_each at: '*function*'|
|Compiler error C3562|intrinsic function '*function*' is limited to have no more than *number* parameters|
|Compiler error C3563|Infinite loop detected when compiling the call graph for the concurrency::parallel_for_each at: '*function*'|
|Compiler error C3564|reading uninitialized value when compiling the call graph for the concurrency::parallel_for_each at: '*function*'|
|Compiler error C3565|The total amount of tile_static memory (*number* bytes) exceeds the limit of *number* bytes when compiling the call graph for the concurrency::parallel_for_each|
|Compiler error C3566|blocks with side effects nested too deeply when compiling the call graph for the concurrency::parallel_for_each at: '*function*'|
|Compiler error C3567|divide or mod by zero detected when compiling the call graph for the concurrency::parallel_for_each at: '*function*'|
|Compiler error C3568|sum of registers exceeds the limit of *number* when compiling the call graph for the concurrency::parallel_for_each. Please simplify your program|
|Compiler error C3569|race condition detected when compiling the call graph for the concurrency::parallel_for_each at: '*function*'|
|Compiler error C3570|illegal use of amp restricted scope when compiling with /clr|
|Compiler error C3571|'*type*': illegal compute domain argument; not a class type|
|Compiler error C3572|'*type*': illegal compute domain argument; missing public member: 'static const int rank' or rank value is non-positive|
|Compiler error C3573|The number of instances of concurrency::graphics::sampler passed to concurrency::parallel_for_each cannot exceed *number*|
|Compiler error C3574|'*type*': illegal tile extents: must be positive and (1) Z <= *number*; (2) Z*Y*X <= *number*|
|Compiler error C3575|'*type*': illegal compute domain argument; missing public member: 'concurrency::index<*number*> _map_index(const concurrency::index<*number*>&) restrict(amp)'|
|Compiler error C3576|'*type*': concurrency::details::_Parallel_for_each argument #*number* has unsupported type|
|Compiler error C3577|concurrency::parallel_for_each kernel argument is illegal: cannot resolve call to member 'void operator()(*type*) restrict(amp)'|
|Compiler error C3578|The size of the function object passed to concurrency::parallel_for_each cannot exceed *number* bytes|
|Compiler error C3579|The number of read-only instances of concurrency::array and concurrency::graphics::texture passed to concurrency::parallel_for_each cannot exceed *number*|
|Compiler error C3580|The number of writable instances of concurrency::array and concurrency::graphics::texture passed to concurrency::parallel_for_each cannot exceed *number*|
|Compiler error C3581|'*type*': unsupported type in amp restricted code|
|Compiler error C3582|Obsolete.|
|Compiler error C3583|'*identifier*': the size of the variable (*number* bytes) is larger than the maximum size (*number* bytes) supported in amp restricted code|
|Compiler error C3584|unsupported usage of tile_static on '*identifier*'|
|Compiler error C3585|'*identifier*' has unsupported storage class in amp restricted code|
|Compiler error C3586|'*identifier*': using global or static variables is unsupported in amp restricted code|
|Compiler error C3587|dynamic_cast is unsupported in amp restricted code|
|Compiler error C3588|casting from '*type1*' to '*type2*' is unsupported in amp restricted code|
|Compiler error C3589|'*string*': unsupported usage of string literals in amp restricted code|
|Compiler error C3590|'*token*': by-reference capture or 'this' capture is unsupported if the lambda is amp restricted|
|Compiler error C3591|typeid operator is unsupported in amp restricted code|
|Compiler error C3592|Inline native assembly ('__asm') is unsupported in amp restricted code|
|Compiler error C3593|'goto' is unsupported in amp restricted code|
|Compiler error C3594|exception handling (try, catch, throw etc.) is unsupported in amp restricted code|
|Compiler error C3595|constant value is out of supported range in amp restricted code|
|Compiler error C3596|'*parameter*' ('*type*'): variable captured by lambda has unsupported type in amp restricted code|
|Compiler error C3597|'*parameter*': '*identifier*' is not allowed to be captured by value if the lambda is amp restricted|
|Compiler error C3598|label statement is unsupported in amp restricted code|
|Compiler error C3599|'*operator*': cannot perform pointer arithmetic on pointer to bool in amp restricted code|
|Compiler error C3600|'*function*': use of tile\_static memory detected when compiling the call graph for the non-tiling concurrency::parallel\_for_each at: '*function*'|
|Compiler error C3601|'*type*': is invalid argument type for amp diagnostic function '*function*'|
|Compiler error C3602|Unsupported control flow detected when compiling the call graph for the concurrency::parallel_for_each at: '*function*'|
|[Compiler error C3603](compiler-error-c3603.md)|'*symbol*': type '*type*' not yet supported|
|Compiler error C3604|'*identifier*': can only create a managed object on the gc heap|
|Compiler error C3605|The total number of samplers (*number* captured and *number* predefined) exceed *number* when compiling the call graph for the concurrency::parallel_for_each at: '*function*'|
|Compiler error C3606|Obsolete.|
|Compiler error C3607|Obsolete.|
|Compiler error C3608|Obsolete.|
|[Compiler error C3609](compiler-error-c3609.md)|'*identifier*': a 'sealed/final' function must be virtual|
|[Compiler error C3610](compiler-error-c3610.md)|'*identifier*': value type must be 'boxed' before method '*method*' can be called|
|[Compiler error C3611](compiler-error-c3611.md)|'*identifier*': a sealed function cannot have a pure-specifier|
|[Compiler error C3612](compiler-error-c3612.md)|'*identifier*': a sealed class cannot have any pure virtual methods|
|Compiler error C3613|missing return type after '->' ('int' assumed)|
|Compiler error C3614|Differing values for pack size within the same class; previous was '*value*', new value is '*value*'|
|[Compiler error C3615](compiler-error-c3615.md)|constexpr function '*function*' cannot result in a constant expression|
|Compiler error C3616|Obsolete.|
|Compiler error C3617|Obsolete.|
|[Compiler error C3618](compiler-error-c3618.md)|'*declaration*': a method marked DllImport cannot be defined|
|[Compiler error C3619](compiler-error-c3619.md)|a template cannot be declared within a managed/WinRT type|
|Compiler error C3620|'*type*': setting the alignment is not allowed on WinRT types|
|Compiler error C3621|'*type*': only the default packing value (*number*) is allowed for WinRT types|
|[Compiler error C3622](compiler-error-c3622.md)|*type*': a class declared as '*keyword*' cannot be instantiated|
|[Compiler error C3623](compiler-error-c3623.md)|'*identifier*': bit fields are not supported in managed/WinRT types|
|[Compiler error C3624](compiler-error-c3624.md)|'*type*': use of this type requires a reference to assembly/module '*identifier*'|
|[Compiler error C3625](compiler-error-c3625.md)|'*class*': a native type cannot derive from a managed/WinRT type '*type*'|
|[Compiler error C3626](compiler-error-c3626.md)|'*identifier*': '*keyword*' keyword can only be used on COM interfaces, member functions and data members that are pointers to delegates|
|[Compiler error C3627](compiler-error-c3627.md)|Only a value type can be boxed|
|[Compiler error C3628](compiler-error-c3628.md)|'*class*': managed/WinRT classes only support public inheritance|
|Compiler error C3629|'*token*': a capture default can only appear at the beginning of a lambda capture list|
|[Compiler error C3630](compiler-error-c3630.md)|error when processing the token '*token*'|
|[Compiler error C3631](compiler-error-c3631.md)|'*event*': cannot overload managed/WinRT events|
|[Compiler error C3632](compiler-error-c3632.md)|'*event*': illegal style of event for *construct*|
|[Compiler error C3633](compiler-error-c3633.md)|cannot define '*identifier*' as a member of managed '*class*'|
|[Compiler error C3634](compiler-error-c3634.md)|'*member*': cannot define an abstract method of a managed/WinRT class|
|Compiler error C3635|'*identifier*': cannot be applied to a managed/WinRT class (use '*identifier*' instead)|
|Compiler error C3636|'*identifier*': cannot be applied to this type|
|[Compiler error C3637](compiler-error-c3637.md)|'*function*': a friend function definition cannot be a specialization of a function template/generic|
|[Compiler error C3638](compiler-error-c3638.md)|'*operator*': the standard boxing and unboxing conversion operators cannot be redefined|
|Compiler error C3639|Obsolete.|
|[Compiler error C3640](compiler-error-c3640.md)|'*member*': a referenced or virtual member function of a local class must be defined|
|[Compiler error C3641](compiler-error-c3641.md)|'*function*': invalid calling convention '*convention*' for function compiled with /clr:pure or /clr:safe|
|[Compiler error C3642](compiler-error-c3642.md)|'*function*': cannot call a function with __clrcall calling convention from native code|
|Compiler error C3643|Obsolete.|
|[Compiler error C3644](compiler-error-c3644.md)|'*function*': cannot compile the function to generate managed code|
|[Compiler error C3645](compiler-error-c3645.md)|'*function*': __clrcall cannot be used on functions compiled to native code|
|[Compiler error C3646](compiler-error-c3646.md)|'*identifier*': unknown override specifier|
|Compiler error C3647|Obsolete.|
|[Compiler error C3648](compiler-error-c3648.md)|this explicit override syntax is not supported for managed types|
|Compiler error C3649|this explicit override syntax is not allowed with /ZW|
|[Compiler error C3650](compiler-error-c3650.md)|'*member*': cannot be used as an explicit override, must be a virtual member function of a base class|
|[Compiler error C3651](compiler-error-c3651.md)|'*member*': cannot be used as an explicit override, must be a member of a base class|
|[Compiler error C3652](compiler-error-c3652.md)|'*member*': a function that explicitly overrides must be virtual|
|[Compiler error C3653](compiler-error-c3653.md)|'*identifier*': cannot be used as a named override: a function being overridden not found; did you forget to name the function explicitly, using a:: operator?|
|[Compiler error C3654](compiler-error-c3654.md)|'*token*': syntax error in explicit override|
|[Compiler error C3655](compiler-error-c3655.md)|'*member*': function already explicitly overridden|
|[Compiler error C3656](compiler-error-c3656.md)|'*keyword*': override specifier cannot be repeated|
|[Compiler error C3657](compiler-error-c3657.md)|a destructor/finalizer cannot explicitly override or be explicitly overridden|
|Compiler error C3658|Obsolete.|
|Compiler error C3659|'*member*': override specifier '*keyword*' is not supported|
|Compiler error C3660|'*member1*': hides inherited member '*member2*'|
|[Compiler error C3661](compiler-error-c3661.md)|explicit override list did not find any methods to override|
|[Compiler error C3662](compiler-error-c3662.md)|'*member*': override specifier '*keyword*' only allowed on member functions of managed/WinRT classes|
|Compiler error C3663|Obsolete.|
|Compiler error C3664|'*member*': cannot be used as an explicit override, must have 'public' or 'protected' accessibility|
|[Compiler error C3665](compiler-error-c3665.md)|'*member*': override specifier '*keyword*' not allowed on a destructor/finalizer|
|[Compiler error C3666](compiler-error-c3666.md)|'*constructor*': override specifier '*keyword*' not allowed on a constructor|
|Compiler error C3667|'*attribute*': attribute does not support pack expansion|
|[Compiler error C3668](compiler-error-c3668.md)|'*member*': method with override specifier 'override' did not override any base class methods|
|[Compiler error C3669](compiler-error-c3669.md)|'*member*': override specifier 'override' not allowed on static member functions or constructors|
|[Compiler error C3670](compiler-error-c3670.md)|'*member*': cannot override inaccessible base class method '*member*'|
|[Compiler error C3671](compiler-error-c3671.md)|'*member*': function does not override '*member*'|
|[Compiler error C3672](compiler-error-c3672.md)|pseudo-destructor expression can only be used as part of a function call|
|[Compiler error C3673](compiler-error-c3673.md)|'*class*': class does not have a copy-constructor|
|Compiler error C3674|could not find standard library module '*module*'|
|[Compiler error C3675](compiler-error-c3675.md)|'*function*': is reserved because '*property*' is defined|
|Compiler error C3676|'*class*': ref class and base class have incompatible attributes '[*attribute*]'|
|Compiler error C3677|string literal after 'operator' cannot have an encoding prefix|
|Compiler error C3678|string literal after 'operator' must be the empty string '""""'|
|Compiler error C3679|expected a literal suffix identifier after 'operator """"'|
|Compiler error C3680|cannot concatenate user-defined string literals with mismatched literal suffix identifiers|
|Compiler error C3681|'fallthrough': attribute may only appear in an enclosing switch statement|
|Compiler error C3682|'operator *identifier*': literal operator/literal operator template cannot be declared to have 'C linkage'|
|Compiler error C3683|cannot define both raw literal operator and literal operator template with the same literal suffix identifier|
|Compiler error C3684|'operator *identifier*': declaration of literal operator has an invalid parameter list|
|Compiler error C3685|'operator *identifier*': literal operator template cannot have function parameters|
|Compiler error C3686|'operator *identifier*': literal operator template must have exactly one template parameter that is a parameter pack|
|Compiler error C3687|'operator *identifier*': literal operator template must have non-type template parameter of type 'char'|
|Compiler error C3688|invalid literal suffix '*suffix*'; literal operator or literal operator template 'operator *identifier*' not found|
|Compiler error C3689|'operator *identifier*': literal operator/literal operator template must be in a global or namespace scope|
|Compiler error C3690|expected a string literal, but found a user-defined string literal instead|
|Compiler error C3691|invalid literal prefix '*prefix*'|
|Compiler error C3692|Obsolete.|
|Compiler error C3693|Obsolete.|
|Compiler error C3694|Obsolete.|
|Compiler error C3695|Obsolete.|
|Compiler error C3696|'*keyword*': cannot use this qualifier on '%'|
|[Compiler error C3697](compiler-error-c3697.md)|'*keyword*': cannot use this qualifier on '^'|
|[Compiler error C3698](compiler-error-c3698.md)|'*type*': cannot use this type as argument of '*operator*'|
|[Compiler error C3699](compiler-error-c3699.md)|'*operator*': cannot use this indirection on type '*type*'|
|Compiler error C3700|Obsolete.|
|[Compiler error C3701](compiler-error-c3701.md)|'*function*': event source has no events|
|[Compiler error C3702](compiler-error-c3702.md)|ATL is required for COM events|
|[Compiler error C3703](compiler-error-c3703.md)|'*event_handler*': an event handler method must have the same storage class as the source '*event*'|
|[Compiler error C3704](compiler-error-c3704.md)|'*member*': a vararg method cannot fire events|
|[Compiler error C3705](compiler-error-c3705.md)|'*function*': cannot find eventing interface|
|[Compiler error C3706](compiler-error-c3706.md)|'*function*': must be a COM interface to fire COM events|
|[Compiler error C3707](compiler-error-c3707.md)|'*member*': dispinterface method must have a dispid|
|[Compiler error C3708](compiler-error-c3708.md)|'*function*': improper use of '*keyword*'; must be a member of a compatible event source|
|[Compiler error C3709](compiler-error-c3709.md)|'*function*': improper syntax for specifying event in __hook/__unhook|
|[Compiler error C3710](compiler-error-c3710.md)|'*function*': improper syntax for specifying event handler in __hook/__unhook|
|[Compiler error C3711](compiler-error-c3711.md)|'*event*': a non-managed event source method must return void or an integral type|
|[Compiler error C3712](compiler-error-c3712.md)|'*event_handler*': an event handler method must return the same type as the source '*event*'|
|[Compiler error C3713](compiler-error-c3713.md)|'*event_handler*': an event handler method must have the same function parameters as the source '*event*'|
|[Compiler error C3714](compiler-error-c3714.md)|'*event_handler*': an event handler method must have the same calling convention as the source '*event*'|
|[Compiler error C3715](compiler-error-c3715.md)|'*pointer*': must be a pointer to '*type*'|
|Compiler error C3716|Obsolete.|
|[Compiler error C3717](compiler-error-c3717.md)|'*member*': a method that fires events cannot be defined|
|[Compiler error C3718](compiler-error-c3718.md)|can only call '__*keyword*' in the context of a member function of the receiving class|
|[Compiler error C3719](compiler-error-c3719.md)|'*member*': an interface based event source can only be used for COM events|
|Compiler error C3720|'*type*': can only implement IDispatch on a dual or dispinterface|
|[Compiler error C3721](compiler-error-c3721.md)|'*signature*': incompatible signature for event|
|[Compiler error C3722](compiler-error-c3722.md)|a generic event is not allowed|
|[Compiler error C3723](compiler-error-c3723.md)|'*function*': could not resolve event|
|[Compiler error C3724](compiler-error-c3724.md)|must #include \<windows.h> to use multi-threading with events|
|Compiler error C3725|Obsolete.|
|Compiler error C3726|Obsolete.|
|[Compiler error C3727](compiler-error-c3727.md)|'*event*': a managed event must be a member function or a data member that is a pointer to a delegate|
|[Compiler error C3728](compiler-error-c3728.md)|'*event*': event does not have a raise method|
|Compiler error C3729|Obsolete.|
|Compiler error C3730|Obsolete.|
|[Compiler error C3731](compiler-error-c3731.md)|incompatible event '*event*' and handler '*event_handler*'; event source and event handler must have the same event type|
|[Compiler error C3732](compiler-error-c3732.md)|'*interface*': a custom interface that fires COM events cannot inherit from IDispatch|
|[Compiler error C3733](compiler-error-c3733.md)|'*event*': improper syntax for specifying a COM event; did you forget '__interface'?|
|[Compiler error C3734](compiler-error-c3734.md)|'*class*': a managed/WinRT class cannot be a coclass|
|Compiler error C3735|Obsolete.|
|[Compiler error C3736](compiler-error-c3736.md)|'*member*': must be a method or, in the case of managed events, optionally a data member|
|[Compiler error C3737](compiler-error-c3737.md)|'*identifier*': a delegate may not have an explicit calling convention|
|[Compiler error C3738](compiler-error-c3738.md)|'*convention*': the calling convention of the explicit instantiation must match that of the template being instantiated|
|[Compiler error C3739](compiler-error-c3739.md)|'*class*': syntax is only supported when the 'layout\_dependent' parameter of event_receiver is true|
|[Compiler error C3740](compiler-error-c3740.md)|'*template*': templates cannot source or receive events|
|[Compiler error C3741](compiler-error-c3741.md)|'*class*': must be a coclass when the 'layout\_dependent' parameter of event_receiver is true|
|Compiler error C3742|'*token1*': unbalanced token sequence in attribute argument of '*attribute*', expected '*token2*'|
|[Compiler error C3743](compiler-error-c3743.md)|can only hook/unhook an entire interface when the 'layout_dependent' parameter of event_receiver is true|
|[Compiler error C3744](compiler-error-c3744.md)|__unhook must have at least 3 arguments for managed events|
|[Compiler error C3745](compiler-error-c3745.md)|'*function*': only an event can be 'raised'|
|Compiler error C3746|standard attribute '*identifier*' may appear at most once in an attribute list|
|[Compiler error C3747](compiler-error-c3747.md)|missing default template/generic parameter: parameter *number*|
|[Compiler error C3748](compiler-error-c3748.md)|'*interface*': unmanaged interfaces may not fire events|
|[Compiler error C3749](compiler-error-c3749.md)|'*attribute*': a custom attribute may not be used inside a function|
|Compiler error C3750|'*token*': unexpected token in attribute list|
|Compiler error C3751|'*identifier*': unexpected identifier in attribute list|
|[Compiler error C3752](compiler-error-c3752.md)|'*attribute*': cannot classify attribute; '*keyword*' should not be used in this context|
|[Compiler error C3753](compiler-error-c3753.md)|a generic property is not allowed|
|[Compiler error C3754](compiler-error-c3754.md)|delegate constructor: member function '*member*' cannot be called on an instance of type '*type*'|
|[Compiler error C3755](compiler-error-c3755.md)|'*identifier*': a delegate may not be defined|
|Compiler error C3756|Obsolete.|
|Compiler error C3757|'*type*': type not allowed for 'constexpr' function|
|Compiler error C3758|'*member*': virtual function cannot be declared 'constexpr'|
|Compiler error C3759|'*member*': member function of non-literal type cannot be declared 'constexpr'|
|Compiler error C3760|please use __property keyword to declare property in managed/WinRT '*class*'|
|[Compiler error C3761](compiler-error-c3761.md)|'*function*': 'retval' can only appear on the last argument of a function|
|[Compiler error C3762](compiler-error-c3762.md)|unable to process attribute '*attribute*'|
|[Compiler error C3763](compiler-error-c3763.md)|'*type*': 'retval' and 'out' can only appear on a data-pointer type|
|[Compiler error C3764](compiler-error-c3764.md)|'*member*': cannot override base class method '*member*'|
|[Compiler error C3765](compiler-error-c3765.md)|'*event*': cannot define an event in a class/struct '*type*' marked as an event_receiver|
|[Compiler error C3766](compiler-error-c3766.md)|'*type*' must provide an implementation for the interface method '*function*'|
|[Compiler error C3767](compiler-error-c3767.md)|'*function*': candidate function(s) not accessible|
|[Compiler error C3768](compiler-error-c3768.md)|cannot take the address of a virtual vararg function in pure managed code|
|[Compiler error C3769](compiler-error-c3769.md)|'*identifier*': a nested class cannot have the same name as the immediately enclosing class|
|Compiler error C3770|'*type*': is not a valid base class|
|[Compiler error C3771](compiler-error-c3771.md)|'*identifier*': friend declaration cannot be found in the nearest namespace scope|
|[Compiler error C3772](compiler-error-c3772.md)|'*identifier*': invalid friend template declaration|
|Compiler error C3773|please use /await compiler switch to enable coroutines|
|Compiler error C3774|cannot find '*scope*::*identifier*': Please include *header* header|
|Compiler error C3775|return type of '*function*' should not be '*type*'|
|Compiler error C3776|cannot return an expresssion of type void in a coroutine with non-void eventual return type|
|Compiler error C3777|'*function*': a coroutine cannot take a variable argument list|
|Compiler error C3778|alloca: cannot be used in a coroutine|
|[Compiler error C3779](https://devblogs.microsoft.com/oldnewthing/20190530-00/?p=102529)|'*function*': a function that returns '*type*' cannot be used before it is defined|
|Compiler error C3780|'*function*': a conversion function that returns '*type*' cannot be used before it is defined|
|Compiler error C3781|'*keyword*': cannot be a used in a coroutine of type '*type*'. Either *keyword* or *keyword* must be present in associated promise_type|
|Compiler error C3782|*type*: a coroutine's promise cannot contain both *keyword* and *keyword*|
|Compiler error C3783|'*identifier*': cannot be a coroutine|
|Compiler error C3784|*keyword* expression cannot appear in this context|
|Compiler error C3785|the first template argument to 'std::integer_sequence' must be an integer type|
|Compiler error C3786|the second template argument to 'std::make_integer_sequence' must be an integer constant greater than or equal to zero|
|Compiler error C3787|cannot deduce the return type of this coroutine|
|Compiler error C3788|Obsolete.|
|Compiler error C3789|Obsolete.|
|Compiler error C3790|Obsolete.|
|Compiler error C3791|Obsolete.|
|Compiler error C3792|Obsolete.|
|Compiler error C3793|Obsolete.|
|Compiler error C3794|Obsolete.|
|Compiler error C3795|Obsolete.|
|Compiler error C3796|Obsolete.|
|[Compiler error C3797](compiler-error-c3797.md)|'*keyword*': event declaration cannot have override specifier (should be placed on event add/remove/raise methods instead)|
|[Compiler error C3798](compiler-error-c3798.md)|'*keyword*': property declaration cannot have override specifier (should be placed on property get/set methods instead)|
|[Compiler error C3799](compiler-error-c3799.md)|indexed property cannot have an empty parameter list|
|[Compiler error C3800](compiler-error-c3800.md)|'*declaration*': cannot mix properties and events|
|Compiler error C3801|'*attribute*': attribute may not have an argument clause|
|Compiler error C3802|Obsolete.|
|[Compiler error C3803](compiler-error-c3803.md)|'*property*': property has a type which is incompatible with one of its accessors '*accessor*'|
|[Compiler error C3804](compiler-error-c3804.md)|'*member*': the accessor methods for a property must either be all static or all non-static|
|[Compiler error C3805](compiler-error-c3805.md)|'*token*': unexpected token, expected either '}' or a ','|
|Compiler error C3806|'*token*': unexpected token, expected either a '{' or a member-initializer|
|[Compiler error C3807](compiler-error-c3807.md)|'*type*': a class with the ComImport attribute cannot derive from '*type*', only interface implementation is allowed|
|[Compiler error C3808](compiler-error-c3808.md)|'*type*': a class with the ComImport attribute cannot define member '*member*', only abstract or dllimport functions are allowed|
|[Compiler error C3809](compiler-error-c3809.md)|'*type*': a managed/WinRT type cannot have any friend functions/classes/interfaces|
|Compiler error C3810|Obsolete.|
|Compiler error C3811|Obsolete.|
|[Compiler error C3812](compiler-error-c3812.md)|'__property' must be the first token in a property declaration|
|[Compiler error C3813](compiler-error-c3813.md)|a property declaration can only appear within the definition of a managed/WinRT type|
|Compiler error C3814|Obsolete.|
|[Compiler error C3815](compiler-error-c3815.md)|return type of method '*member*' must match type of the last parameter of a setter|
|[Compiler error C3816](compiler-error-c3816.md)|'class/struct *member*' was previously declared or defined with a different managed/WinRT modifier|
|[Compiler error C3817](compiler-error-c3817.md)|'*declaration*': property can only be applied to a function|
|[Compiler error C3818](compiler-error-c3818.md)|array property declaration '*property*' shall not overload an index property '*property*'|
|Compiler error C3819|Obsolete.|
|[Compiler error C3820](compiler-error-c3820.md)|'*identifier*': initializers must be managed|
|[Compiler error C3821](compiler-error-c3821.md)|'*function*': managed type or function cannot be used in an unmanaged function|
|Compiler error C3822|Obsolete.|
|Compiler error C3823|Obsolete.|
|[Compiler error C3824](compiler-error-c3824.md)|'*type*': this type cannot appear in this context (function parameter, return type, or a static member)|
|[Compiler error C3825](compiler-error-c3825.md)|'*type*': a managed/WinRT class can only support managed/WinRT events|
|Compiler error C3826|Obsolete.|
|Compiler error C3827|standard attribute 'deprecated' may have either no arguments or one string literal describing the reason|
|[Compiler error C3828](compiler-error-c3828.md)|placement arguments cannot be specified for a '*keyword*' expression for type '*type*'|
|Compiler error C3829|standard attribute 'noreturn' may only be applied to functions|
|[Compiler error C3830](compiler-error-c3830.md)|'*type1*': cannot inherit from '*type2*', value types can only inherit from interface classes|
|[Compiler error C3831](compiler-error-c3831.md)|'*identifier*': '*type*' cannot have a pinned data member or a member function returning a pinning pointer|
|[Compiler error C3832](compiler-error-c3832.md)|'*typelib*': type library looks as if it was built for 32-bit pointers; please change the 'ptrsize' qualifier|
|[Compiler error C3833](compiler-error-c3833.md)|'*type*': invalid target type for *identifier*|
|[Compiler error C3834](compiler-error-c3834.md)|illegal explicit cast to a pinning pointer; use a pinned local variable instead|
|Compiler error C3835|Obsolete.|
|[Compiler error C3836](compiler-error-c3836.md)|a static constructor is not allowed to have a member initializer list|
|Compiler error C3837|attributes are not allowed in this context|
|[Compiler error C3838](compiler-error-c3838.md)|cannot inherit from '*type*'|
|[Compiler error C3839](compiler-error-c3839.md)|cannot change alignment in a managed/WinRT type|
|Compiler error C3840|Obsolete.|
|Compiler error C3841|Obsolete.|
|[Compiler error C3842](compiler-error-c3842.md)|'*identifier*': 'const' and 'volatile' qualifiers on member functions of managed/WinRT types are not supported|
|Compiler error C3843|'*identifier*': ref-qualifiers on member functions of managed/WinRT types are not supported|
|Compiler error C3844|'*identifier*': cannot import symbol from '*source*': as '*identifier*' already exists in the current scope|
|Compiler error C3845|Obsolete.|
|[Compiler error C3846](compiler-error-c3846.md)|'*identifier*': cannot import symbol from '*source*': as '*identifier*' has already been imported from another assembly '*assembly*'|
|Compiler error C3847|Obsolete.|
|[Compiler error C3848](compiler-error-c3848.md)|expression having type '*type*' would lose some const-volatile qualifiers in order to call '*identifier*'|
|[Compiler error C3849](compiler-error-c3849.md)|function-style call on an expression of type '*type*' would lose const and/or volatile qualifiers for all *number* available operator overloads|
|[Compiler error C3850](compiler-error-c3850.md)|'*token*': a universal-character-name specifies an invalid character|
|[Compiler error C3851](compiler-error-c3851.md)|'*token*': a universal-character-name cannot designate a character in the basic character set|
|[Compiler error C3852](compiler-error-c3852.md)|'*member*' having type '*type*': aggregate initialization could not initialize this member|
|[Compiler error C3853](compiler-error-c3853.md)|'=': re-initializing a reference or assignment through a reference-to-function is illegal|
|[Compiler error C3854](compiler-error-c3854.md)|expression to left of '=' evaluates to a function. Cannot assign to a function (a function is not an l-value)|
|[Compiler error C3855](compiler-error-c3855.md)|'*function*': template/generic parameter '*identifier*' is incompatible with the declaration|
|[Compiler error C3856](compiler-error-c3856.md)|'*class*': class is not a class template/generic|
|[Compiler error C3857](compiler-error-c3857.md)|'*template*': multiple template/generic parameter lists are not allowed|
|[Compiler error C3858](compiler-error-c3858.md)|'*identifier*': cannot be redeclared in current scope|
|[Compiler error C3859](compiler-error-c3859.md)|virtual memory range for PCH exceeded; please recompile with a command line option of '-Zm*number*' or greater|
|[Compiler error C3860](compiler-error-c3860.md)|template/generic argument list following class template/generic name must list parameters in the order used in template/generic parameter list|
|[Compiler error C3861](compiler-error-c3861.md)|'*identifier*': identifier not found|
|[Compiler error C3862](compiler-error-c3862.md)|'*function*': cannot compile an unmanaged function with /clr:pure or /clr:safe|
|Compiler error C3863|array type '*type*' is not assignable|
|Compiler error C3864|Obsolete.|
|[Compiler error C3865](compiler-error-c3865.md)|'*keyword*': can only be used on native member functions|
|[Compiler error C3866](compiler-error-c3866.md)|destructor/finalizer call missing argument list|
|[Compiler error C3867](compiler-error-c3867.md)|'*function*': non-standard syntax; use '&' to create a pointer to member|
|[Compiler error C3868](compiler-error-c3868.md)|'*type*': constraints on generic parameter '*parameter*' differ from those on the declaration|
|[Compiler error C3869](compiler-error-c3869.md)|gcnew constraint is missing empty parameter list '()'|
|Compiler error C3870|'*parameter*': '__declspec(*specifier*)' can only be applied to parameters of integral type|
|Compiler error C3871|'*parameter*': '__declspec(guard(overflow))' is only supported on the first 64 parameters of a function|
|[Compiler error C3872](compiler-error-c3872.md)|'0x*value*': this character is not allowed in an identifier|
|[Compiler error C3873](compiler-error-c3873.md)|'0x*value*': this character is not allowed as a first character of an identifier|
|[Compiler error C3874](compiler-error-c3874.md)|return type of '*identifier*' should be '*type1*' instead of '*type2*'|
|Compiler error C3875|call of non-static member function missing argument list|
|Compiler error C3876|Obsolete.|
|Compiler error C3877|Obsolete.|
|Compiler error C3878|Obsolete.|
|Compiler error C3879|'*member*': cannot be an initonly data member|
|[Compiler error C3880](compiler-error-c3880.md)|'*member*': cannot be a literal data member|
|Compiler error C3881|can only inherit constructor from direct base|
|Compiler error C3882|'*class*': constructor has already been inherited from '*class*'|
|Compiler error C3883|'*member*': an initonly static data member must be initialized|
|Compiler error C3884|'*type*': An array of unknown size cannot be value-initialized|
|Compiler error C3885|'*type*': An array of unknown size cannot be initialized with an empty initializer list|
|[Compiler error C3886](compiler-error-c3886.md)|'*member*': a literal data member must be initialized|
|[Compiler error C3887](compiler-error-c3887.md)|'*member*': the initializer for a literal data member must be a constant expression|
|[Compiler error C3888](compiler-error-c3888.md)|'*member*': the const expression associated with this literal data member is not supported by C++/CLI|
|Compiler error C3889|Obsolete.|
|[Compiler error C3890](compiler-error-c3890.md)|'*member*': you cannot take the address of a literal data member|
|[Compiler error C3891](compiler-error-c3891.md)|'*member*': a literal data member cannot be used as a l-value|
|[Compiler error C3892](compiler-error-c3892.md)|'*variable*': you cannot assign to a variable that is const|
|[Compiler error C3893](compiler-error-c3893.md)|'*member*': l-value use of initonly data member is only allowed in an instance constructor of class '*class*'|
|[Compiler error C3894](compiler-error-c3894.md)|'*member*': l-value use of initonly static data member is only allowed in the class constructor of class '*class*'|
|[Compiler error C3895](compiler-error-c3895.md)|'*member*': *type* data members cannot be 'volatile'|
|[Compiler error C3896](compiler-error-c3896.md)|'*member*': improper initializer: this literal data member can only be initialized with 'nullptr'|
|Compiler error C3897|Obsolete.|
|[Compiler error C3898](compiler-error-c3898.md)|'*member*': *type* data members can only be members of managed types|
|[Compiler error C3899](compiler-error-c3899.md)|'*member*': l-value use of initonly data member is not allowed directly within a parallel region in class '*class*'|
|[Compiler error C3900](compiler-error-c3900.md)|'*member*': not allowed in current scope|
|[Compiler error C3901](compiler-error-c3901.md)|'*function*': must have return type '*type*'|
|[Compiler error C3902](compiler-error-c3902.md)|'*function*': type of last parameter must be '*type*'|
|[Compiler error C3903](compiler-error-c3903.md)|'*property*': does not have set or get method|
|[Compiler error C3904](compiler-error-c3904.md)|'*property*': must specify *number* parameter(s)|
|Compiler error C3905|unaligned accesses are not supported for intrinsic type '*type*'|
|Compiler error C3906|intrinsic type '*type*' is not a supported return or argument type for vararg or unprototyped functions|
|Compiler error C3907|Obsolete.|
|[Compiler error C3908](compiler-error-c3908.md)|access level less restrictive than that of '*identifier*'|
|[Compiler error C3909](compiler-error-c3909.md)|a managed/WinRT event declaration must occur in a managed/WinRT type|
|[Compiler error C3910](compiler-error-c3910.md)|'*event*': must define member '*member*'|
|[Compiler error C3911](compiler-error-c3911.md)|'*member*': function must have type '*type*'|
|[Compiler error C3912](compiler-error-c3912.md)|'*event*': type of event must be a delegate type|
|[Compiler error C3913](compiler-error-c3913.md)|a default property must be indexed|
|[Compiler error C3914](compiler-error-c3914.md)|a default property cannot be static|
|[Compiler error C3915](compiler-error-c3915.md)|'*identifier*' has no default indexed property (class indexer)|
|Compiler error C3916|Obsolete.|
|[Compiler error C3917](compiler-error-c3917.md)|'*token*': obsolete *construct* declaration style (did you mean to use '[' ']' instead?)|
|[Compiler error C3918](compiler-error-c3918.md)|usage requires '*identifier*' to be a data member|
|[Compiler error C3919](compiler-error-c3919.md)|'*function*': function must have type '*return_type* (*type*)'|
|[Compiler error C3920](compiler-error-c3920.md)|'*operator*': cannot define a postfix increment/decrement CLR/WinRT operator Calling the postfix CLR/WinRT operator will call the corresponding prefix CLR/WinRT operator (op_Increment/op_Decrement), but with postfix semantics|
|Compiler error C3921|Obsolete.|
|Compiler error C3922|Obsolete.|
|[Compiler error C3923](compiler-error-c3923.md)|'*member*': local class, struct or union definitions are not allowed in a member function of a managed/WinRT class|
|Compiler error C3924|error in argument #*number* of delegate constructor call '*constructor*':|
|Compiler error C3925|expected a loop (for, while, or do) following '*directive*' directive|
|Compiler error C3926|invalid constant in 'parallel' directive|
|Compiler error C3927|'->': trailing return type is not allowed after a non-function declarator|
|Compiler error C3928|'->': trailing return type is not allowed after a parenthesized declarator|
|Compiler error C3929|Obsolete.|
|Compiler error C3930|'*function*': no overloaded function has restriction specifiers that are compatible with the ambient context '*context*'|
|Compiler error C3931|'*type*': cannot call a function that has restriction specifiers that are incompatible with the ambient context|
|Compiler error C3932|Obsolete.|
|Compiler error C3933|'*class*': destructor's restriction specifiers must cover the union of restrictions on all constructors|
|Compiler error C3934|a function that is in any form of 'main' cannot have restriction specifiers other than restrict(cpu)|
|Compiler error C3935|'*identifier*': redefinition; overlapping restriction specifiers|
|Compiler error C3936|'*identifier*': unrecognized restriction specifier|
|Compiler error C3937|empty restriction specifier is not allowed|
|Compiler error C3938|'*identifier*': multiple restriction specifiers are not supported on extern \042C\042 functions|
|Compiler error C3939|'*identifier*': pointer to member functions, function pointers, references to functions with 'amp' restriction specifier are not allowed|
|Compiler error C3940|'*identifier*': identifier not found - possible mismatch between compiler and library versions. Please ensure vccorlib.h/.lib, vccorlib120.dll and c1xx.dll match|
|Compiler error C3941|'*condition*': requires '/clr' command line option|
|Compiler error C3942|Obsolete.|
|Compiler error C3943|Obsolete.|
|Compiler error C3944|Obsolete.|
|Compiler error C3945|'*type*': unable to throw or catch a winrt object which doesn't derive from Platform::Exception|
|Compiler error C3946|'*type*': typeid cannot be applied to this type|
|Compiler error C3947|'*typeid*': typeid cannot be applied to a pack expansion|
|Compiler error C3948|'*keyword*': a pack expansion cannot appear in this context|
|Compiler error C3949|a pack expansion, '...', cannot appear in a parenthesized abstract declarator|
|Compiler error C3950|Obsolete.|
|Compiler error C3951|Cannot use pointer-to-member in projected WinRT type '*type*'. Use a delegate instead.|
|Compiler error C3952|'*type*': WinRT does not support 'in/out' arrays. Use 'const Array\<T>^' for 'in' and 'WriteOnlyArray\<T>' or 'Array\<T>^*' for 'out' on public APIs|
|Compiler error C3953|Cannot use managed class '*type*' in WinRT module.|
|Compiler error C3954|'*type*': An array returned from a published method on a WinRT type must use the form 'Array\<T>^'|
|Compiler error C3955|'*type*': A public constructor cannot contain an 'out' parameter or 'WriteOnlyArray\<T>'|
|Compiler error C3956|'*type*': Type is marked as Exclusive To '*type*' and cannot be used as a base of '*derived_type*'|
|Compiler error C3957|'*type*': cannot use 'new' on a WinRT type; use 'ref new' instead|
|Compiler error C3958|'*type*': cannot use 'gcnew' on a WinRT type; use 'ref new' instead|
|Compiler error C3959|'ref new' may only be used to create an object with WinRT type|
|Compiler error C3960|Obsolete.|
|Compiler error C3961|static constructor is not supported|
|Compiler error C3962|generic class is not supported|
|Compiler error C3963|multi-dimensional array is not supported|
|Compiler error C3964|jagged array is not supported|
|Compiler error C3965|parameter array is not supported|
|Compiler error C3966|'*function*': generic function is not supported|
|Compiler error C3967|error importing '*identifier*' from module '*module*'|
|Compiler error C3968|the token '*token*' is not valid as module name separator; use period ('.') instead|
|Compiler error C3969|inconsistent module names: '*module1*' and '*module1*'|
|Compiler error C3970|'*identifier*': '*keyword*' can only be applied to 'ref class' or 'ref struct' at global scope or namespace scope|
|Compiler error C3971|'*type*': partial definition cannot appear after full definition|
|Compiler error C3972|'*type*': 'partial' can only be applied to class declarations or definitions|
|Compiler error C3973|Obsolete.|
|Compiler error C3974|Obsolete.|
|Compiler error C3975|'class/struct *identifier*' was previously declared or defined with a different modifier|
|Compiler error C3976|'*identifier1*' must be declared as 'public' in order to use '*identifier2*'|
|Compiler error C3977|Usage requires a reference to an assembly that defines '*identifier*'|
|Compiler error C3978|'*identifier*': a static property is not allowed as a member of a WinRT interface or value type|
|Compiler error C3979|'*type*': use attribute '*attribute*' instead of '*value*'|
|Compiler error C3980|'*type*' cannot be emitted into metadata|
|Compiler error C3981|'*type*': a value type cannot have any static data members '*identifier*'|
|Compiler error C3982|'*type*': a value type cannot have any non-public data members '*identifier*'|
|Compiler error C3983|'*type*': a value type cannot have any public non-data members '*identifier*'|
|Compiler error C3984|'*type*': a non-value type cannot have any public data members '*identifier*'|
|Compiler error C3985|'*identifier*': signature of public member contains private type '*member*'|
|Compiler error C3986|'*identifier*': signature of public member contains native type '*member*'|
|Compiler error C3987|'*identifier*': signature of public member contains native type '*type*'|
|Compiler error C3988|'*type*': a native type cannot be public|
|Compiler error C3989|'*type*': a nested type cannot be public|
|Compiler error C3990|'*type*': attribute '*attribute*' cannot be private or nested|
|Compiler error C3991|'*type*': cannot implement a non-public or nested interface '*interface*'|
|Compiler error C3992|'*identifier*': signature of public member contains invalid type '*type*'|
|Compiler error C3993|'*type*': a value type must contain at least one public field|
|Compiler error C3994|'*type*': a value type cannot implement interfaces or have virtual functions|
|Compiler error C3995|'*type*': a value type cannot have any event members '*identifier*'|
|Compiler error C3996|Obsolete.|
|Compiler error C3998|'c++*version*': unsupported C++ version; defaulting to 'c++*version*'|
|Compiler error C3999|UNKNOWN ERROR  Please choose the Technical Support command on the Visual C++  Help menu, or open the Technical Support help file for more information|

## See also

[C/C++ Compiler and build tools errors and warnings](../compiler-errors-1/c-cpp-build-errors.md) \
[Compiler errors C2000 - C3999, C7000 - C7999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
