---
title: "Compiler Errors C3400 Through C3499 | Microsoft Docs"
ms.custom: ""
ms.date: "11/17/2017"
ms.technology: ["cpp-diagnostics"]
ms.topic: "error-reference"
f1_keywords: ["C3401", "C3402", "C3403", "C3404", "C3405", "C3406", "C3407", "C3410", "C3411", "C3416", "C3419", "C3422", "C3424", "C3425", "C3426", "C3427", "C3428", "C3429", "C3430", "C3431", "C3432", "C3433", "C3434", "C3435", "C3436", "C3437", "C3438", "C3439", "C3440", "C3441", "C3442", "C3443", "C3444", "C3445", "C3446", "C3471", "C3472", "C3473", "C3474", "C3475", "C3476", "C3477", "C3478", "C3479", "C3486", "C3494", "C3497"]
helpviewer_keywords: ["C3401", "C3402", "C3403", "C3404", "C3405", "C3406", "C3407", "C3410", "C3411", "C3416", "C3419", "C3422", "C3424", "C3425", "C3426", "C3427", "C3428", "C3429", "C3430", "C3431", "C3432", "C3433", "C3434", "C3435", "C3436", "C3437", "C3438", "C3439", "C3440", "C3441", "C3442", "C3443", "C3444", "C3445", "C3446", "C3471", "C3472", "C3473", "C3474", "C3475", "C3476", "C3477", "C3478", "C3479", "C3486", "C3494", "C3497"]
dev_langs: ["C++"]
ms.assetid: a5651dfb-c402-4e01-b3ae-28f371e51d6a
author: "corob-msft"
ms.author: "corob"
ms.workload: ["cplusplus"]
---
# Compiler Errors C3400 Through C3499

The articles in this section of the documentation explain a subset of the error messages that are generated by the compiler.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## Error messages

|Error|Message|
|-----------|-------------|
|[Compiler Error C3400](compiler-error-c3400.md)|circular constraint dependency involving '*constraint1*' and '*constraint2*'|
|Compiler Error C3401|'*specifier*': invalid assembly access specifier - only 'private' is allowed on class templates|
|Compiler Error C3402|'*function*': cannot resolve overload except in the current scope|
|Compiler Error C3403|thread_local cannot be used with /clr:pure or /clr:safe|
|Compiler Error C3404|'*construct*': unexpected syntax error|
|Compiler Error C3405|'*function*': cannot resolve overload without complete descriptor|
|Compiler Error C3406|'*keyword*': cannot be used in an elaborated type specifier|
|Compiler Error C3407|'*type*' cannot be used in this context|
|[Compiler Error C3408](compiler-error-c3408.md)|'*attribute*': attribute is not allowed on template definitions|
|[Compiler Error C3409](compiler-error-c3409.md)|empty attribute block is not allowed|
|Compiler Error C3410|'*identifier*': the type of the explicit instantiation '*type*' does not match the type of the variable template '*type*'|
|Compiler Error C3411|'*type*' is not valid as the size of an array as it is not an integer type|
|[Compiler Error C3412](compiler-error-c3412.md)|'*specialization*': cannot specialize template in current scope|
|[Compiler Error C3413](compiler-error-c3413.md)|'*template*': invalid explicit instantiation|
|[Compiler Error C3414](compiler-error-c3414.md)|'*function*': imported member function can't be defined|
|[Compiler Error C3415](compiler-error-c3415.md)|multiple '*section*' sections found with different attributes ('0x*value*')|
|Compiler Error C3416|Obsolete.|
|[Compiler Error C3417](compiler-error-c3417.md)|'*declarator*': value types cannot contain user-defined special member functions|
|[Compiler Error C3418](compiler-error-c3418.md)|access specifier '*specifier*' is not supported|
|Compiler Error C3419|Obsolete.|
|[Compiler Error C3420](compiler-error-c3420.md)|'*function*': a finalizer cannot be virtual|
|[Compiler Error C3421](compiler-error-c3421.md)|'*function*': you cannot call the finalizer for this class as it is either inaccessible or it does not exist|
|Compiler Error C3422|'*declaration*': mismatched types '*type*' and '*type*'|
|Compiler Error C3423|Obsolete.|
|Compiler Error C3424|'*type*': a function-style cast to an array type is not allowed|
|Compiler Error C3425|cannot throw pointer to object of incomplete type '*type*'|
|Compiler Error C3426|cannot throw object of incomplete type '*type*'|
|Compiler Error C3427|'*context*': '*keyword*' cannot be used with layout_version(*number*)|
|Compiler Error C3428|'*context*': '*keyword*' can only be applied to class declarations or definitions|
|Compiler Error C3429|'*context*': '*keyword*' cannot be applied to a union|
|Compiler Error C3430|a scoped enumeration must have a name|
|Compiler Error C3431|'*identifier*': *type1* cannot be redeclared as *type2*|
|Compiler Error C3432|'*identifier*': a forward declaration of an unscoped enumeration must have an underlying type|
|Compiler Error C3433|'*identifier*': all declarations of an enumeration must have the same underlying type, was '*type1*' now '*type2*'|
|Compiler Error C3434|'*context*': enumerator value '*number*' cannot be represented as '*type*', value is '*number*'|
|Compiler Error C3435|character set '*name*' is not supported|
|Compiler Error C3436|#pragma setlocale is not supported when /source-charset, /execution-charset, or /utf-8 has been specified|
|Compiler Error C3437|#pragma execution_character_set is not supported when /source-charset, /execution-charset, or /utf-8 has been specified|
|Compiler Error C3438|'*context*': '*value*' cannot be applied to a managed/WinRT class|
|Compiler Error C3439|layout_version(*number*): invalid version number|
|Compiler Error C3440|'*declaration*': layout_version(*number*) incompatible with a prior declaration|
|Compiler Error C3441|'*declaration*': '*keyword*' cannot be applied after the class has been defined|
|Compiler Error C3442|Initializing multiple members of union: '*member1*' and '*member2*'|
|Compiler Error C3443|The default member initializer for '*class*' is recursive|
|Compiler Error C3444|Empty aggregate class '*class*' must be initialized with '{}'|
|[Compiler Error C3445](compiler-error-c3445.md)|copy-list-initialization of '*type*' cannot use an explicit constructor|
|[Compiler Error C3446](compiler-error-c3446.md)|'*class*': a default member initializer is not allowed for a member of a value class|
|Compiler Error C3447|Obsolete.|
|Compiler Error C3448|Obsolete.|
|Compiler Error C3449|Obsolete.|
|[Compiler Error C3450](compiler-error-c3450.md)|'*type*': not an attribute; cannot specify [System::AttributeUsageAttribute]/[Windows::Foundation::Metadata::AttributeUsageAttribute]|
|[Compiler Error C3451](compiler-error-c3451.md)|'*attribute*': cannot apply unmanaged attribute to '*type*'|
|[Compiler Error C3452](compiler-error-c3452.md)|list argument member not constant|
|[Compiler Error C3453](compiler-error-c3453.md)|'*attribute*': attribute not applied because qualifier '*qualifier*' did not match|
|[Compiler Error C3454](compiler-error-c3454.md)|[attribute] not allowed on class declaration|
|[Compiler Error C3455](compiler-error-c3455.md)|'*attribute*': none of the attribute constructors matched the arguments|
|[Compiler Error C3456](compiler-error-c3456.md)|[source\_annotation_attribute] not allowed on managed/WinRT class declaration|
|[Compiler Error C3457](compiler-error-c3457.md)|'*attribute*': attribute does not support unnamed arguments|
|[Compiler Error C3458](compiler-error-c3458.md)|'[*attribute*]': attribute '[*attribute*]' already specified for '*identifier*'|
|[Compiler Error C3459](compiler-error-c3459.md)|'[*attribute*]': attribute allowed only on class indexer (default indexed property)|
|[Compiler Error C3460](compiler-error-c3460.md)|'*type*': only a user-defined type can be forwarded|
|[Compiler Error C3461](compiler-error-c3461.md)|'*type*': only a managed/WinRT type can be forwarded|
|[Compiler Error C3462](compiler-error-c3462.md)|'*type*': only an imported type can be forwarded|
|[Compiler Error C3463](compiler-error-c3463.md)|'*type*': type not allowed in attribute 'implements'|
|[Compiler Error C3464](compiler-error-c3464.md)|'*type*' a nested type cannot be forwarded|
|[Compiler Error C3465](compiler-error-c3465.md)|to use type '*type*' you must reference the assembly '*assembly*'|
|[Compiler Error C3466](compiler-error-c3466.md)|'*type*': a specialization of a generic class cannot be forwarded|
|[Compiler Error C3467](compiler-error-c3467.md)|'*type*': this type has already been forwarded|
|[Compiler Error C3468](compiler-error-c3468.md)|'*type*': you can only forward a type to an assembly: '*identifier*' is not an assembly|
|[Compiler Error C3469](compiler-error-c3469.md)|'*type*': a generic class cannot be forwarded|
|[Compiler Error C3470](compiler-error-c3470.md)|'*class*': a class cannot have both an indexer (default indexed property) and an operator[]|
|Compiler Error C3471|new module name *name* (set on command line) conflicts with previous name *name*|
|Compiler Error C3472|new output file name *filename* (set on command line) conflicts with previous file name *filename*|
|Compiler Error C3473|no output pathname or module name specified.|
|Compiler Error C3474|could not open output file '*filename*'|
|Compiler Error C3475|syntax error in input file '*filename*'|
|Compiler Error C3476|could not open file '*filename*' for input|
|Compiler Error C3477|a lambda cannot appear in an unevaluated context|
|Compiler Error C3478|'*identifier*': an array cannot be captured by copy|
|Compiler Error C3479|SAL annotations on lambdas are not supported|
|[Compiler Error C3480](compiler-error-c3480.md)|'*variable*': a lambda capture variable must be from an enclosing function scope|
|[Compiler Error C3481](compiler-error-c3481.md)|'*identifier*': lambda capture variable not found|
|[Compiler Error C3482](compiler-error-c3482.md)|'this' can only be used as a lambda capture within a non-static member function|
|[Compiler Error C3483](compiler-error-c3483.md)|'*identifier*' is already part of the lambda capture list|
|[Compiler Error C3484](compiler-error-c3484.md)|syntax error: expected '->' before the return type|
|[Compiler Error C3485](compiler-error-c3485.md)|a lambda definition cannot have any cv-qualifiers|
|Compiler Error C3486|Obsolete.|
|[Compiler Error C3487](compiler-error-c3487.md)|'*type*': all return expressions must deduce to the same type: previously it was '*type*'|
|[Compiler Error C3488](compiler-error-c3488.md)|'&*identifier*' is not allowed when the default capture mode is by-reference|
|[Compiler Error C3489](compiler-error-c3489.md)|'&*identifier*' is required when the default capture mode is by copy|
|[Compiler Error C3490](compiler-error-c3490.md)|'*identifier*' cannot be modified because it is being accessed through a const object|
|[Compiler Error C3491](compiler-error-c3491.md)|'*identifier*': a by copy capture cannot be modified in a non-mutable lambda|
|[Compiler Error C3492](compiler-error-c3492.md)|'*identifier*': you cannot capture a member of an anonymous union|
|[Compiler Error C3493](compiler-error-c3493.md)|'*identifier*' cannot be implicitly captured because no default capture mode has been specified|
|Compiler Error C3494|'this' cannot be explicitly captured because an enclosing capture mode does not allow it|
|[Compiler Error C3495](compiler-error-c3495.md)|'*identifier*': identifier in capture must be a variable with automatic storage duration declared in the reaching scope of the lambda|
|[Compiler Error C3496](compiler-error-c3496.md)|'this' is always captured by value: '&' ignored|
|Compiler Error C3497|you cannot construct an instance of a lambda|
|[Compiler Error C3498](compiler-error-c3498.md)|'*identifier*': you cannot capture a variable that has a managed/WinRT type|
|[Compiler Error C3499](compiler-error-c3499.md)|a lambda that has been specified to have a void return type cannot return a value|

