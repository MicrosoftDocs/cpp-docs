---
description: "Learn more about: Compiler errors C3400 Through C3499"
title: "Compiler errors C3400 Through C3499"
ms.date: 06/01/2022
f1_keywords: ["C3401", "C3402", "C3403", "C3404", "C3405", "C3406", "C3407", "C3410", "C3411", "C3416", "C3419", "C3422", "C3423", "C3424", "C3425", "C3426", "C3427", "C3428", "C3429", "C3430", "C3431", "C3432", "C3433", "C3434", "C3435", "C3436", "C3437", "C3438", "C3439", "C3440", "C3441", "C3442", "C3443", "C3444", "C3447", "C3448", "C3449", "C3471", "C3472", "C3473", "C3474", "C3475", "C3476", "C3477", "C3478", "C3479", "C3486", "C3494", "C3497"]
helpviewer_keywords: ["C3401", "C3402", "C3403", "C3404", "C3405", "C3406", "C3407", "C3410", "C3411", "C3416", "C3419", "C3422", "C3423", "C3424", "C3425", "C3426", "C3427", "C3428", "C3429", "C3430", "C3431", "C3432", "C3433", "C3434", "C3435", "C3436", "C3437", "C3438", "C3439", "C3440", "C3441", "C3442", "C3443", "C3444", "C3447", "C3448", "C3449", "C3471", "C3472", "C3473", "C3474", "C3475", "C3476", "C3477", "C3478", "C3479", "C3486", "C3494", "C3497"]
---
# Compiler errors C3400 Through C3499

The articles in this section of the documentation explain a subset of the error messages that are generated by the compiler.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## Error messages

| Error | Message |
|--|--|
| [Compiler error C3400](compiler-error-c3400.md) | circular constraint dependency involving '*constraint1*' and '*constraint2*' |
| Compiler error C3401 | '*specifier*': invalid assembly access specifier - only 'private' is allowed on class templates |
| Compiler error C3402 | '*function*': cannot resolve overload except in the current scope |
| Compiler error C3403 | thread_local cannot be used with /clr:pure or /clr:safe |
| Compiler error C3404 | '*construct*': unexpected syntax error |
| Compiler error C3405 | '*function*': cannot resolve overload without complete descriptor |
| Compiler error C3406 | '*keyword*': cannot be used in an elaborated type specifier |
| Compiler error C3407 | '*type*' cannot be used in this context |
| [Compiler error C3408](compiler-error-c3408.md) | '*attribute*': attribute is not allowed on template definitions |
| [Compiler error C3409](compiler-error-c3409.md) | empty attribute block is not allowed |
| Compiler error C3410 | '*identifier*': the type of the explicit instantiation '*type*' does not match the type of the variable template '*type*' |
| Compiler error C3411 | '*type*' is not valid as the size of an array as it is not an integer type |
| [Compiler error C3412](compiler-error-c3412.md) | '*specialization*': cannot specialize template in current scope |
| [Compiler error C3413](compiler-error-c3413.md) | '*template*': invalid explicit instantiation |
| [Compiler error C3414](compiler-error-c3414.md) | '*function*': imported member function can't be defined |
| [Compiler error C3415](compiler-error-c3415.md) | multiple '*section*' sections found with different attributes ('0x*value*') |
| Compiler error C3416 | Obsolete. |
| [Compiler error C3417](compiler-error-c3417.md) | '*declarator*': value types cannot contain user-defined special member functions |
| [Compiler error C3418](compiler-error-c3418.md) | access specifier '*specifier*' is not supported |
| Compiler error C3419 | Obsolete. |
| [Compiler error C3420](compiler-error-c3420.md) | '*function*': a finalizer cannot be virtual |
| [Compiler error C3421](compiler-error-c3421.md) | '*function*': you cannot call the finalizer for this class as it is either inaccessible or it does not exist |
| Compiler error C3422 | '*declaration*': mismatched types '*type*' and '*type*' |
| Compiler error C3423 | Obsolete. |
| Compiler error C3424 | '*type*': a function-style cast to an array type is not allowed |
| Compiler error C3425 | cannot throw pointer to object of incomplete type '*type*' |
| Compiler error C3426 | cannot throw object of incomplete type '*type*' |
| Compiler error C3427 | '*context*': '*keyword*' cannot be used with layout_version(*number*) |
| Compiler error C3428 | '`__declspec(`*keyword*`)`' can only be applied to class declarations or definitions |
| Compiler error C3429 | '*context*': '*keyword*' cannot be applied to a union |
| Compiler error C3430 | a scoped enumeration must have a name |
| Compiler error C3431 | '*identifier*': *type1* cannot be redeclared as *type2* |
| Compiler error C3432 | '*identifier*': a forward declaration of an unscoped enumeration must have an underlying type |
| Compiler error C3433 | '*identifier*': all declarations of an enumeration must have the same underlying type, was '*type1*' now '*type2*' |
| Compiler error C3434 | '*context*': enumerator value '*number*' cannot be represented as '*type*', value is '*number*' |
| Compiler error C3435 | character set '*name*' is not supported. |
| Compiler error C3436 | #pragma setlocale is not supported when /source-charset, /execution-charset, or /utf-8 has been specified |
| Compiler error C3437 | #pragma execution_character_set is not supported when /source-charset, /execution-charset, or /utf-8 has been specified |
| Compiler error C3438 | '*context*': '*value*' cannot be applied to a managed/WinRT class |
| Compiler error C3439 | layout_version(*number*): invalid version number |
| Compiler error C3440 | '*declaration*': layout_version(*number*) incompatible with a prior declaration |
| Compiler error C3441 | '*declaration*': '*keyword*' cannot be applied after the class has been defined |
| Compiler error C3442 | Initializing multiple members of union: '*member1*' and '*member2*' |
| Compiler error C3443 | The default member initializer for '*class*' is recursive |
| Compiler error C3444 | Empty aggregate class '*class*' must be initialized with '{}' |
| [Compiler error C3445](compiler-error-c3445.md) | copy-list-initialization of '*type*' cannot use an explicit constructor |
| [Compiler error C3446](compiler-error-c3446.md) | '*class*': a default member initializer is not allowed for a member of a value class |
| Compiler error C3447 | *operand* to the conditional operator `?:` is of type 'void', but the *other-operand* is neither a throw-expression nor of type 'void' |
| Compiler error C3448 | the number of identifiers must match the number of array elements or members in a structured binding declaration |
| Compiler error C3449 | the number of identifiers must match the value of `std::tuple_size<type-name>::value` in a structured binding of tuple-like type |
| [Compiler error C3450](compiler-error-c3450.md) | '*type*': not an attribute; cannot specify [`System::AttributeUsageAttribute`]/[Windows::Foundation::Metadata::AttributeUsageAttribute] |
| [Compiler error C3451](compiler-error-c3451.md) | '*attribute*': cannot apply unmanaged attribute to '*type*' |
| [Compiler error C3452](compiler-error-c3452.md) | list argument member not constant |
| [Compiler error C3453](compiler-error-c3453.md) | '*attribute*': attribute not applied because qualifier '*qualifier*' did not match |
| [Compiler error C3454](compiler-error-c3454.md) | [attribute] not allowed on class declaration |
| [Compiler error C3455](compiler-error-c3455.md) | '*attribute*': none of the attribute constructors matched the arguments |
| [Compiler error C3456](compiler-error-c3456.md) | [source-annotation-attribute] not allowed on managed/WinRT class declaration |
| [Compiler error C3457](compiler-error-c3457.md) | '*attribute*': attribute does not support unnamed arguments |
| [Compiler error C3458](compiler-error-c3458.md) | '[*attribute*]': attribute '[*attribute*]' already specified for '*identifier*' |
| [Compiler error C3459](compiler-error-c3459.md) | '[*attribute*]': attribute allowed only on class indexer (default indexed property) |
| [Compiler error C3460](compiler-error-c3460.md) | '*type*': only a user-defined type can be forwarded |
| [Compiler error C3461](compiler-error-c3461.md) | '*type*': only a managed/WinRT type can be forwarded |
| [Compiler error C3462](compiler-error-c3462.md) | '*type*': only an imported type can be forwarded |
| [Compiler error C3463](compiler-error-c3463.md) | '*type*': type not allowed in attribute 'implements' |
| [Compiler error C3464](compiler-error-c3464.md) | '*type*' a nested type cannot be forwarded |
| [Compiler error C3465](compiler-error-c3465.md) | to use type '*type*' you must reference the assembly '*assembly*' |
| [Compiler error C3466](compiler-error-c3466.md) | '*type*': a specialization of a generic class cannot be forwarded |
| [Compiler error C3467](compiler-error-c3467.md) | '*type*': this type has already been forwarded |
| [Compiler error C3468](compiler-error-c3468.md) | '*type*': you can only forward a type to an assembly: '*identifier*' is not an assembly |
| [Compiler error C3469](compiler-error-c3469.md) | '*type*': a generic class cannot be forwarded |
| [Compiler error C3470](compiler-error-c3470.md) | '*class*': a class cannot have both an indexer (default indexed property) and an operator[] |
| Compiler error C3471 | new module name *module-name* (set on command line) conflicts with previous name *module-name* |
| Compiler error C3472 | new output file name *filename* (set on command line) conflicts with previous file name *filename* |
| Compiler error C3473 | no output pathname or module name specified. |
| Compiler error C3474 | could not open output file '*filename*' |
| Compiler error C3475 | syntax error in input file '*filename*' |
| Compiler error C3476 | could not open file '*filename*' for input |
| Compiler error C3477 | a lambda can only appear in an unevaluated context with '*C++ version*' or later |
| Compiler error C3478 | '*identifier*': an array of unknown bounds cannot be captured by copy |
| Compiler error C3479 | SAL annotations on lambdas are not supported |
| [Compiler error C3480](compiler-error-c3480.md) | '*variable*': a lambda capture variable must be from an enclosing function scope |
| [Compiler error C3481](compiler-error-c3481.md) | '*identifier*': lambda capture variable not found |
| [Compiler error C3482](compiler-error-c3482.md) | 'this' can only be used as a lambda capture within a non-static member function |
| [Compiler error C3483](compiler-error-c3483.md) | '*identifier*' is already part of the lambda capture list |
| [Compiler error C3484](compiler-error-c3484.md) | syntax error: expected '->' before the return type |
| [Compiler error C3485](compiler-error-c3485.md) | a lambda definition cannot have any cv-qualifiers (Obsolete in Visual Studio 2022.) |
| Compiler error C3486 | a parameter for a lambda cannot have a default argument (Obsolete in Visual Studio 2022.) |
| [Compiler error C3487](compiler-error-c3487.md) | '*type*': all return expressions must deduce to the same type: previously it was '*type*' |
| [Compiler error C3488](compiler-error-c3488.md) | '`&`*identifier*' cannot be explicitly captured when the default capture mode is by reference (`&`) |
| [Compiler error C3489](compiler-error-c3489.md) | '`&`*identifier*' is required when the default capture mode is by copy (`=`) |
| [Compiler error C3490](compiler-error-c3490.md) | '*identifier*' cannot be modified because it is being accessed through a const object |
| [Compiler error C3491](compiler-error-c3491.md) | '*identifier*': a by copy capture cannot be modified in a non-mutable lambda |
| [Compiler error C3492](compiler-error-c3492.md) | '*identifier*': you cannot capture a member of an anonymous union |
| [Compiler error C3493](compiler-error-c3493.md) | '*identifier*' cannot be implicitly captured because no default capture mode has been specified |
| Compiler error C3494 | 'this' cannot be explicitly captured because an enclosing capture mode does not allow it |
| [Compiler error C3495](compiler-error-c3495.md) | '*identifier*': a simple capture must be a variable with automatic storage duration declared in the reaching scope of the lambda |
| [Compiler error C3496](compiler-error-c3496.md) | '`this`' is always captured by copy: '`&`' ignored |
| Compiler error C3497 | cannot construct an instance of this lambda |
| [Compiler error C3498](compiler-error-c3498.md) | '*identifier*': you cannot capture a variable that has a managed/WinRT type |
| [Compiler error C3499](compiler-error-c3499.md) | a lambda that has been specified to have a void return type cannot return a value |

## See also

[C/C++ Compiler and build tools errors and warnings](../compiler-errors-1/c-cpp-build-errors.md) \
[Compiler errors C2000 - C3999, C7000 - C7999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
