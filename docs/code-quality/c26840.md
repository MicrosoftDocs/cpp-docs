---
description: "Learn more about: Warning C26840"
title: Warning C26840 
ms.date: 10/03/2022
f1_keywords: ["C26840", "ALLOCATION_DEALLOCATION_MISMATCH", "__WARNING_ALLOCATION_DEALLOCATION_MISMATCH"]
helpviewer_keywords: ["C26840"]
ms.assetid: 2fbe9dc5-fa43-47b9-97a7-3f8215da1d40 # TODO (@carsonradtke): I generated this with `PS > (New-Guid).ToString()`. Is that OK?
---
# Warning C26840

> Memory allocated with '\<allocation-function\>' is being deallocated with '\<wrong-deallocation-function\>'. Use '\<correct-deallocation-function\>' instead.

## Remarks

This warning indicates that the memory was allocated with one family of allocation functions, but was freed with a deallocation function from a different family. This usage is undefined behavior according to the C++ standard and the Microsoft C++ implementation.

The exact ramifications of this defect are difficult to predict. It might result in leaks for classes with destructors that perform memory deallocation. It could cause inconsistent behavior for classes with destructors that perform semantically significant operations, or memory corruptions and crashes. In other cases the mismatch might be unimportant, depending on the implementation of the compiler and its libraries. Analysis tools can't always distinguish between these situations.

If memory is allocated with one family of allocation functions, it should be freed with a matching deallocation function.

C26840 covers the following allocation/deallocation pairs:

- C++ scalar new (`new`) must be deallocated with scalar delete (`delete`).
- C++ array new (`new[]`) must be deallocated with array delete (`delete[]`).
- C/C++ `malloc`/`calloc`/`realloc` must be deallocated with `free` (or `realloc`).
- Windows `HeapAlloc` must be deallocated with `HeapFree`.
- Windows `GlobalAlloc` must be deallocated with `GlobalFree`.
- Windows `LocalAlloc` must be deallocated with `LocalFree`.
- Windows `MIDL_user_allocate` must be deallocated with `MIDL_user_free`.
- Component Object Model (COM) `CoTaskMemAlloc` must be deallocated with `CoTaskMemFree`.

Code analysis name: `ALLOCATION_DEALLOCATION_MISMATCH`

## Example

The following sample code generates warning C6278:

```cpp
void f() {
    int *pInt = (int *)calloc(10, sizeof(int));
    // code ...
    delete pInt; // C26840: Memory allocated with 'calloc' is being deallocated with 'delete'. Use 'free' instead.
}

void g() {
    char * str = new char[50];
    // code ...
    delete str; // C26840: Memory allocated with 'new[]' is being deallocated with 'delete'. Use 'delete[]' instead.
}
```

Manual memory management has many pitfalls in terms of memory leaks and exceptions. To avoid these kinds of potential leaks altogether, use the mechanisms that are provided by the C++ Standard Library (STL). These mechanisms include [`shared_ptr`](../standard-library/shared-ptr-class.md), [`unique_ptr`](../standard-library/unique-ptr-class.md), and containers such as [`vector`](../standard-library/vector.md). For more information, see [Smart pointers](../cpp/smart-pointers-modern-cpp.md) and [C++ Standard Library](../standard-library/cpp-standard-library-reference.md).
