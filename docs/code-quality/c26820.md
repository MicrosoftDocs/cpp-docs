---
title: C26820
description: "Reference for Microsoft C++ Code Analysis warning C26820 in Visual Studio."
ms.date: 04/07/2020
ms.topic: "reference"
f1_keywords: ["C26820"]
helpviewer_keywords: ["C26820"]
---
# C26820

> Assigning by value when a const-reference would suffice, use const T&amp; instead (p.9).

For more information, see [P.9](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#p9-dont-waste-time-or-space) in the C++ Core Guidelines.

This check covers non-obvious and easy-to-miss behavior when assigning a reference to a variable marked `auto`.
The type of the `auto` variable is resolved to a value rather than a reference, and an implicit copy is performed.

## Example:
```cpp
MyClass& ref = ...;
auto var = ref; // C26820 (`var` takes a copy of the object referred to by `ref`)
```
## Solution
```cpp
MyClass& ref = ...;
const auto& var = ref; // OK
```

## Remarks:

- This warning does not get raised for scalars, smart pointers, views, and types whose size does not exceed twice the platform-dependent pointer size.
- This warning does not get raised when the variable gets mutated, since marking it `auto&` would introduce side-effects to the mutation.
- This warning does not get raised when the reference comes from a temporary object, as that would result in a dangling reference. For example:
  ```cpp
  std::optional<int> TryGetNumber();
  ...
  const auto& val = TryGetNumber().value();
  val++; // Temporary from TryGetNumber() is destroyed and val is now dangling
  ```
