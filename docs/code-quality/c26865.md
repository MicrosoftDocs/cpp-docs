---
description: "Learn more about: Warning C26865"
title: Warning C26865 
ms.date: 10/03/2022
f1_keywords: ["C26865", "ALLOCATION_DEALLOCATION_MISMATCH", "__WARNING_ALLOCATION_DEALLOCATION_MISMATCH"]
helpviewer_keywords: ["C26865"]
ms.assetid: 2fbe9dc5-fa43-47b9-97a7-3f8215da1d40
---
# Warning C26865

> Memory allocated with '\<allocation-function\>' is being deallocated with '\<wrong-deallocation-function\>'. Use '\<correct-deallocation-function\>' instead.

This rule was added in Visual Studio 2026 18.0.

## Remarks

This warning indicates that the memory was allocated with one family of allocation functions, but was freed with a deallocation function from a different family. This usage results in undefined behavior according to C/C++ and the Microsoft MSVC implementation.

The exact ramifications of this defect are difficult to predict. It might result in leaks for classes with destructors that perform memory deallocation. It could cause inconsistent behavior for classes with destructors that perform semantically significant operations, or memory corruptions and crashes. In other cases the mismatch might be unimportant, depending on the implementation of the compiler and its libraries. Analysis tools can't always distinguish between these situations.

If memory is allocated with one family of allocation functions, it should be freed with a matching deallocation function.

C26865 covers the following allocation/deallocation pairs:

- C++ scalar new (`new`) must be deallocated with scalar delete (`delete`).
- C++ array new (`new[]`) must be deallocated with array delete (`delete[]`).
- C/C++ `malloc`/`calloc`/`realloc` must be deallocated with `free` (or `realloc`).
- Windows `HeapAlloc` must be deallocated with `HeapFree`.
- Windows `GlobalAlloc` must be deallocated with `GlobalFree`.
- Windows `LocalAlloc` must be deallocated with `LocalFree`.
- Windows `MIDL_user_allocate` must be deallocated with `MIDL_user_free`.
- Component Object Model (COM) `CoTaskMemAlloc` must be deallocated with `CoTaskMemFree`.

Code analysis name: `ALLOCATION_DEALLOCATION_MISMATCH`

## Example

The following sample code generates warning C26865:

```cpp
void f() {
    int *pInt = (int *)calloc(10, sizeof(int));
    // code ...
    delete pInt; // C26865: Memory allocated with 'calloc' is being deallocated with 'delete'. Use 'free' instead.
}

void g() {
    char * str = new char[50];
    // code ...
    delete str; // C26865: Memory allocated with 'new[]' is being deallocated with 'delete'. Use 'delete[]' instead.
}
```

Manual memory management has many pitfalls in terms of memory leaks and exceptions. To avoid these kinds of potential leaks altogether, use the mechanisms that are provided by the C++ Standard Library (STL). These mechanisms include [`shared_ptr`](../standard-library/shared-ptr-class.md), [`unique_ptr`](../standard-library/unique-ptr-class.md), and containers such as [`vector`](../standard-library/vector.md). For more information, see [Smart pointers](../cpp/smart-pointers-modern-cpp.md) and [C++ Standard Library](../standard-library/cpp-standard-library-reference.md).
